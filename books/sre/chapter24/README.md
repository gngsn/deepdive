# CHAPTER 24. Distributed Periodic Scheduling with Cron

<i><small>크론을 이용한 분산된 주기적 스케줄링</small></i>


## Cron

**크론(Cron)**: 사용자가 지정한 시간이나 간격에 따라 정기적으로 작업을 실행하도록 만들어진 유닉스(Unix) 유틸리티

### Introduction

- **Crontab**: 가장 일반적인 시간 표기법
- **`crond`**: 크론 스케줄들을 로드하고 지정된 시간이 되면 실행하는 데몬.

### Reliability Perspective

<i><small>신뢰성 관점에서의 크론</small></i>

**장애 도메인**: 단일 실패 지점을 공유하는 하드웨어 구성 요소 집합

- **크론의 Failure Domain**: 단 하나의 머신
- **크론의 실패 도메인**: 하나의 머신
  - 머신이 작동하지 않으면 크론 스케줄러나 작업이 실행되지 않음
  - 가령, 크론 스케줄러가 다른 작업 머신에서 작업을 실행하는 경우(e.g. SSH 사용), '스케줄러 머신'과 '실제 작업 수행 머신' 이라는 두 개의 실패 도메인 존재
- `crond` 혹은 머신 재시작 시, **crontab 설정**만 지속되면 됨
  - **fire-and-forget** 방식으로 작업을 실행 → 크론 실행은 한번 수행 후 추적하지 않음
- `anacron`은 예외. 
  - 시스템 다운 시, 실행되었어야 할 작업 중 **일일 또는 그보다 적은 빈도의 작업만을 재실행**함. 
  - 워크스테이션과 노트북의 유지보수 작업에 매우 유용하며, 마지막 실행 타임스탬프를 저장하는 파일로 관리됨

<br/>

### Cron Jobs and Idempotency

<small><i>크론 작업과 멱등성</i></small>

- 멱등성이 없어도 되는 서비스
  - 가비지 컬렉션 프로세스 같은 일부 크론 작업은 멱등성을 가짐.  
  - 오동작 시에도, 여러 번 실행하는 것의 안전성을 보장.  
- 멱등성이 반드시 필요한 서비스
  - 뉴스레터를 발송하는 프로세스. 크론 작업으로 실행하는 것은 한 번 이상 실행되어서는 안 됨.
  - '변경 없이 실패'(fail closed)하는 방식 선호. 
    - 시스템이 잘못된 상태가 되는 것을 지양
    - 건너뛴 작업의 복구가 반복된 작업을 복구하는 것보다 수월.

<br/>

## Cron at Large Scale

<small><i>대용량 시스템 내에서의 크론 작업</i></small>
<br/>

### Extended Infrastructure

<small><i>인프라스트럭처의 확장</i></small>


- 기본적으로 크론은 단일 머신으로 제한
- 단일 머신에 크론 서비스를 호스팅하면 신뢰성 측면에서 **재앙** 가능성이 있음
- 신뢰성을 높이기 위해 프로세스를 머신에서 분리
- **데이터센터 스케줄링 시스템이 서비스를 배포할 머신을 결정하고 머신 장애를 처리함**
- 머신 재배치는 로컬 상태 손실 및 서비스 재배치 시간 초과 문제를 일으킬 수 있음
- 데이터 손실을 방지하기 위해 분산 파일 시스템 사용, 시간이 중요한 작업의 경우 **Hot Spares** 이용
  - 빠르게 작업을 재개할 수 있고, 작업을 다시 예약 하는 시간을 획기적으로 줄일 수 있음 

<br/>

### Extended Requirements

<small><i>요구사항의 확장</i></small>

- 단일 머신 시스템은 제한된 격리 환경에서 모든 프로세스가 실행됨
- 데이터센터 규모 배포는 격리를 강화하기 위해 컨테이너 사용
- 데이터센터 자원 부족 시 크론 작업 지연 가능성 존재, 자원 요구사항 추적 필요
- 특정 머신에서 프로세스 실행을 분리하면 부분 실행 실패 위험 증가
  - 새 크론 작업 배포 시 다중 RPC 필요할 수 있음
  - 가령, 일부 RPC 실패에 대한 복구 절차 필요
- **다중 머신 배포**: 복잡한 생태계, 부분적인 데이터센터 장애 시에도 서비스가 작동하도록 보장 필요
- **단일 머신 배포**: 낮은 지연 시간 및 데이터센터 스케줄러와 운명을 공유하는 장점

<br/>

## Building Cron at Google

<small><i>구글에서 구현한 크론 서비스</i></small>

<br/>

### Tracking the State of Cron Jobs

<small><i>크론 작업 상태 추적</i></small>

- 크론 작업 상태를 유지하고 장애 발생 시 신속히 복원 필요
- 크론 작업의 상태 **일관성**이 가장 중요 (예: 급여 실행, 이메일 뉴스레터 발송 등은 멱등성이 아님)
- 상태 추적 방법:
  1. 분산 스토리지에 데이터 저장
  2. 크론 서비스 자체에 상태의 일부를 저장하는 서비스 사용

- **구글은 두 번째 옵션 채택**:
  - 분산 파일 시스템의 작은 쓰기는 비용이 많이 들고 지연 시간이 큼
  - 광범위한 영향을 미치는 기본 서비스(크론)는 의존성을 최소화 해야 함

<br/>

### The Use of Paxos

<small><i>Paxos 사용</i></small>

- 여러 크론 서비스 레플리카를 배포하고 Paxos 분산 합의 알고리즘 사용하여 상태 일관성 유지
- 그룹 멤버의 대다수가 가용한 한, 새로운 상태 변경 처리 가능
- Fast Paxos 리더 레플리카를 크론 서비스 리더로 사용

<br/><img src="./img/figure24-1" /><br/>

- 새로운 리더는 이전 리더의 미완료 작업을 인수인계
- 리더 선출 프로토콜을 통해 1분 이내의 장애 전환 시간 달성

- Paxos에 저장하는 가장 중요한 상태: 각 크론 작업의 정보
  - 각 크론 작업의 시작과 종료를 쿼럼에 동기화

<br/>

### The Roles of the Leader and the Follower

<small><i>리더와 그 팔로워들의 역할</i></small>

<br/>

### Leader

- 리더 레플리카는 크론 작업을 활성화하는 유일한 레플리카
- 내부 스케줄러를 통해 크론 작업을 예정된 실행 시간에 맞춰 관리

**예약된 실행 시간이 되면:** 
1. 리더 레플리카는 크론 작업 실행 시작을 공지. 
2. 해당 작업의 새로운 실행 시간을 예약
3. 크론 작업의 실행의 명세는 가장 최근에 실행된 이후로 변경되었을 수도 있음. 
4. 이 실행 명세는 팔로워들에도 반드시 동기화 시켜야 함.
   - 크론 작업의 '시작 시간'을 이용해 특정 작업과 그 실행여부까지 식별할 수 있어야 함. 

- Paxos 통신은 동기적이라서, 과반수의 서버 레프리카가 실행에 대한 수신이 확인되기 전까지, 실제 크론 작업의 실행이 진행되지 않음.

<br/><img src="./img/figure24-2" /><br/>

- Paxos를 통해 동기식으로 크론 작업 시작 및 완료를 다른 레플리카에 알림
- 리더 레플리카가 리더십을 잃으면 즉시 데이터센터 스케줄러와의 상호작용 중지

<br/>

### Follower

- 리더로부터 전달받은 상태를 추적하여 필요 시 리더 역할을 위임받음
- Paxos를 통해 리더로부터 상태 변경을 동기적으로 수신
- 각 크론 작업의 다음 실행 시간을 로컬에 동기화
- 리더 레플리카가 죽거나 오작동 시 새 리더를 선출, 1분 내에 선출 완료 필요
- 새로운 리더는 미완료 작업을 인수하고 완료해야 함

<br/>

### Resolving partial failures

<small><i>부분 실패 해결</i></small>

- 리더와 데이터센터 스케줄러 간의 상호작용이 중간에 실패할 수 있음
- 크론 작업 실행에는 두 개의 동기화 지점 존재:
  1. 작업 실행 직전
  2. 작업 실행 완료 후
- RPC가 실제로 전송되었는지 판단할 수 있는 조건 필요:
  - 재실행이 안전한 멱등 작업
  - 외부 시스템의 상태를 조회하여 작업 완료 여부 확인
- 데이터센터 작업의 상태를 조회하고, 필요 시 중지하거나 유지보수 수행
- 작업 이름을 사전 생성하여 모든 크론 서비스 레플리카에 배포
- 크론 서비스 리더가 실행 중 죽으면 새로운 리더는 **사전 정의된 이름을 사용해 상태 조회 후 누락된 작업 실행**
- **작업 이름에 예정된 실행 시간 포함**하여 중복 실행 방지
- 인프라에 따라 중복 실행 위험과 실행 누락 위험 간의 트레이드오프 고려

<br/>

### Storing the State

<small><i>상태 저장</i></small>

- 기본적으로 Paxos는 상태의 변경에 대한 연속적인 로그, 상태의 변경이 동기적으로 추가됨
- Paxos는 아래 두 문제가 존재
  1. 로그를 무한정 기록할수는없으므로로그자체의크기가작아야한다. 
  2. 로그를 다른어딘가에저장해야한다.

- 상태 변경 로그를 압축하여 무한 확장을 방지해야 함
- 로그는 어딘가에 저장되어야 함
- 현재 상태의 스냅샷을 통해 무한 로그 재생 없이 상태를 재구성할 수 있음
- 로그 유실 시 스냅샷 이후의 상태만 손실됨
- 스냅샷 저장이 가장 중요 
  - 스냅샷 유실 시 최악의 상황이 발생
  - 분산 파일 시스템에 백업 필요

- **데이터 저장 방법**
  - 분산 저장소에 외부 저장
  - 크론 서비스 자체에 상태를 저장하는 저장소를 추가하는 방법
- 구글은 두 가지 방식을 혼합 사용
- Paxos 로그를 로컬 디스크에 저장하고 스냅샷은 로컬 디스크와 분산 파일 시스템에 백업

- **로그와 스냅샷 관리**
  - 분산 파일 시스템에 로그를 로컬 디스크에만 저장
  - 새로 투입된 복제 서버는 상태 스냅샷을 로드하면서 네트워크 상에 이미 실행 중인 다른 복제 서버로 부터 모든 로그들을 불러
  - 머신 재시작 시, 다른 스냅샷을 네트워크를 통해 다른 실행 중인 복제본으로부터 가져와 서비스 신뢰성을 유지

<br/>

### Running Large Cron

<small><i>대규모 크론 시스템 운영</i></small>

- 수천 대의 머신에서 cron 서비스 실행 시 사용량 급증과 문제 발생
- **thundering herd 문제**: 모든 머신이 동시에 cron 작업을 실행하려고 함
- 설정에 따라 데이터센터 사용량 급증
- 기존의 '*' (asterisk) 문자와 함께, 확장된 crontab 형식인 '?' 으로 임의 값 설정 가능하게 함
- 해시 함수를 사용해 cron 작업 실행을 균등하게 분산
- 여전히 특정 시간에 스파이크 현상 발생

<br/><img src="./img/figure24-3" /><br/>

<br/>

## Summary

<small><i>결론</i></small>

- 대용량 분산 환경에서 Paxos 알고리즘을 활용하고 있는 견고한 크론 서비스를 구축할 수 있었음

<br/>
