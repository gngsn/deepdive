# 14. Coroutines 

<small><i>코루틴</i></small>

**코루틴**: 다른 여러 연산을 스레드를 사용할 때처럼 블록<sub>Block</sub>시키지 않고, 독립적으로 실행하면서 여러 동시 작업을 동기화하고 조화시킬 수 있는 도구

<br/>

## 14.1 Concurrency vs. parallelism

<small><i>동시성과 병렬성</i></small>

**동시성과 병렬성 개념 사이의 관계**
- **동시성**<sup>concurrency</sup>: 코드가 동시에 실행될 수 있는 여러 부분으로 나뉘는 일반적인 능력을 의미
- **병렬성**<sup>parallelism</sup>: 여러 CPU 코어에서 실제로 여러 작업을 동시에 실행하는 것을 의미

모든 작업을 물리적으로 함께 실행할 필요는 없음


코드의 여러 부분을 돌아가면서 실행하는 것도 동시성 시스템임. 

이는 CPU 코어가 하나뿐인 시스템에서 실행되는 애플리케이션까지도 동시성을 사용할 수 있다는 뜻

이런 경우 여러 동시성 태스크를 계속 전환해가면서 동시성을 달성

코어가 하나뿐이라 하더라도 사용자 인터페이스의 반응성을 유지하면서 복잡한 계산을 수행하기에 충분

<br>

#### 동시성<sup>Concurrent</sup>

```
           Process
---[UI]--[Calc]--[UI]--[Calc]-->

실행을 번갈아 실행
→ 애플리케이션이 싱글 코어여도, 한 번에 하나 이상의 작업을 수행
```

<br>

병렬 계산은 현대적 멀티코어 하드웨어를 효과적으로 사용할 수 있고, 그 효율을 더 높이는 경우도 있음


<br>

#### 병렬성<sup>Parallelism</sup>

```
           Process
---[UI]--[UI]--[UI]--[UI]-->
---[Calc]--[Calc]--[Calc]-->

여러 CPU 코어에서 여러 작업을 물리적으로 동시에 실행하는 것
이 예제에서는 오래 걸리는 계산을 백그라운드에서 진행하면서 UI를 렌더링
```

<br/>

## 14.2 코틀린의 동시성 처리 방법: 일시중단 함수와 코루틴

- 비동기 + 넌블로킹 동시성 코드를 우아하게 작성할 수 있게 해줌
- 경량: 전통적 스레드와 비교하면 훨씬 가볍게 작동
- 구조화된 동시성: 동시성 작업과 그 생명주기를 관리할 수 있는 기능 제공

<br>

### 14.2.1 스레드와 코루틴 비교

코틀린 스레드는 자바와 100% 호환

- 코루틴은 스레드보다 훨씬 가볍고, 생성 및 관리 비용이 저렴해 수만 개도 쉽게 실행 가능
- 시스템 자원을 블록하지 않고 일시 중단 및 재개가 가능해 비동기 작업에 효율적
- 구조화된 동시성(Structured Concurrency)으로 계층적 관리와 취소, 오류 처리가 용이함
- 짧은 시간 동안 실행되는 세밀한 작업에도 적합함
- 동시 작업 구성이 단순해지고, 오류 발생 시 관련 코루틴을 함께 취소할 수 있음

<br>

> **일시 중단 함수**: 스레드를 블록시키는 단점이 없이 순차적 코드처럼 보이는 동시성 코드를 작성할 수 있게 해줌

<br>

**Example. 스레드 시작**

```kotlin
import kotlin.concurrent.thread
 
fun main() {
    println("I'm on ${Thread.currentThread().name}")            // I'm on main
    thread {
        println("And I'm on ${Thread.currentThread().name}")    // And I'm on Thread-0
    }
}
```

<br/>

#### ✔️ 스레드

: JVM에서 생성하는 각 스레드는 운영체제가 관리하는 시스템 스레드

- 애플리케이션의 반응성을 높임
- 멀티코어 CPU의 여러 코어에 작업을 분산시켜 시스템 효율을 향상시킴

**한계**
- **생성·관리 비용이 큼**: **메모리 할당**과 **전환 비용**이 누적되어 **성능 저하** 유발
  - **메모리 할당**: 각 스레드는 몇 메가바이트의 메모리를 할당받아야 함
  - **전환 비용**: 스레드 간 전환이 운영체제 커널 수준에서 실행되어 오버헤드가 큼
- 응답 대기 중에 **시스템 자원을 점유한 채 대기**함
  - **작업 완료를 기다리는 동안 블록**되어, **자원을 비효율적으로 사용**함 (e.g. 네트워크 요청 등)

<br>

✅ 스레드 생성은 신중하게 결정해야 하며, 짧은 시간 동안 잠깐 사용하는 것은 피하는 것이 좋음

→ 코틀린은 스레드에 대한 대안으로 코루틴이라는 추상화를 도입

<br>

#### 코루틴과 프로젝트 룸

[🔗 Project Loom](https://wiki.openjdk.org/display/loom)


| 구분               | 자바 레거시 스레드 API                                    | 프로젝트 룸 (Project Loom)                                | 코틀린 코루틴 API                                                         |
| ------------------ | --------------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------------------- |
| 사용 환경          | 스레드 생성 비용이 크고, 자주 생성하지 않는 상황에 최적화 | JVM에 가상 스레드 도입, 기존 스레드/코드와 호환성 중시    | 경량 동시성 처리가 필요한 코드에 최적화, 코루틴을 자주 생성해도 부담 없음 |
| 생성/관리 비용     | 높음 (메모리, 전환 비용 등)                               | 낮음 (가상 스레드로 경량 동시성 제공)                     | 매우 낮음 (작은 작업에도 부담 없이 생성 가능)                             |
| 동시성 작업        | 수천 개 수준이 한계                                       | 수십만 개의 가상 스레드 생성 가능                         | 수십만 ~ 수백만 개의 코루틴 생성 가능                                     |
| 메모리/자원 효율   | 비효율적 (스레드가 자원 점유)                             | 효율적 (필요할 때만 자원 사용, 최소화)                    | 효율적 (필요할 때만 자원 사용, 최소화)                                    |
| 코드 구조화        | 구조화된 동시성 지원 미흡                                 | 구조화된 동시성 실험적 지원(향후 발전 예정)               | 구조화된 동시성 지원, 자원 누수 방지                                      |
| 일시중단 함수 구분 | 없음                                                      | 없음 (일반 함수와 일시중단 함수 구분 없음)                | `suspend` 키워드로 명확히 구분                                            |
| 플랫폼 독립성      | JVM 한정                                                  | JVM 한정                                                  | JVM 외에도 다양한 플랫폼에서 사용 가능                                    |
| 사용 예시          | 신중하게 스레드 생성, 짧은 작업에는 부적합                | 기존 자바 코드와 I/O 중심 코드의 경량화, 가상 스레드 활용 | 사소한 작업(예: 카운터 증가)에도 코루틴 생성 가능                         |

<br/>

#### 결론

**코루틴**
- 코틀린 코루틴은 매우 가볍고 효율적으로 설계되어, 자주 생성·소멸되는 고도의 동시성 코드에 적합

**프로젝트 룸**
- 주요 목표는 기존의 I/O 중심 레거시 코드를 가상 스레드로 포팅할 수 있게 하는 것.
- 룸은 기존의 자바 스레드와 I/O API에 맞춰 재구성됨
  - 빠른 로컬 계산과 네트워크로부터 예측할 수 없는 시간 동안 정보를 기다려야 하는 함수(코틀린 코루틴의 일시 중단 함수) 사이에 언어 수준에서의 구분이 없음 
  - 지역적 작업(UI, 캐시, 상태 갱신)이 원격 데이터 접근과 혼합된 대규모 코드베이스에서 코드를 이해하는 것이 더 어려워짐
